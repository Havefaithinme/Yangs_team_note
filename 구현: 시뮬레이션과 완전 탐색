구현: 시뮬레이션과 완전 탐색 
구현(Implementation)

구현이란 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정. 

흔히 알고리즘 대회에서 구현 유형의 문제란 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 말함. 
예시)
알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제 - 언어에 따라서도 달라질 수 있다. 
실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제 
문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제 
적절한 라이브러리를 찾아서 사용해야 하는 문제 

많은 연습이 필요한 부분이다. 

일반적으로 알고리즘 문제에서의 2차원 공간은 행렬(Matrix)의 의미로 사용된다. 
시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 활용된다. 

상하좌우 : 문제 설명
여행가 A 는 N x N 크기의 정사각형 공간 위에 서있음
이 공간은 1 x 1크기의 정사각형응로 나누어져 있음. 가장 왼쪽 위 좌표는 (1,1)이고, 가장 오른쪽 아래가 (N,N)임. 여행자는 상 하 좌 우 로만 이동이 가능하고 시작 좌표는 항상 (1,1)이다. 다음은 이동 계획서다
계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L,R,U,D 중 하나의 문자가 반복적으로 적혀 있음. 
각 문자의 의미는 다음과 같다. 
L : 왼쪽으로 한칸 이동 
R : 오른쪽으로 한칸 이동
U : 위로 한칸 이동
D : 아래로 한칸 이동

이때 여행가가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. 

입력조건 : 첫째 줄에 공간의 크기를 나타내는 N이 주어진다 (1 <= N <= 100)
 	 둘째 줄에 여행가가 이동할 계획서 내용이 주어진다 (1 <= 이동횟수 <= 100)
출력조건 : 첫째 줄에 여행가가 최종적으로 도착할 지점의 좌표 (X,Y)를 공백을 기준으로 구분하여 출력한다. 

#동,북,서,남

dx = [0, -1, 0, 1]
dy = [1, 0, -1, 0]
#현재 위치
x, y = 2, 2 

for i in range(4):
    # 다음 위치 
    nx = x + dx[i]
    ny = y + dy[i]
    print(nx, ny)

대략적인 소스코드의 흐름 
인풋으로 N과 이동계획서를 받는다. 
여행가의 현재 위치를 (1,1)에 저장한다. 
R L D U 에 방향벡터에 맞는 값을 키 밸류로 저장한다. 
for문을 돌면서 이동이 가능하면 여행가의 현재 위치를 저장한다. 
최종적인 여행자의 위치를 리턴한다. 

답안예시 
#N입력받기 
# L R U D에 따른 이동 방향 
#이동 계획을 하나씩 확인하기 
#이동 후 좌표 구하기 
#공간을 벗어나는 경우 무시 
#이동 수행 


n = int(input())
x, y = 1, 1
plans = input().split()

dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L','R','U','D']

for plan in plans:
  for i in range(len(move_types)):
    if plan == move_types[i]:
      nx = x + dx[i]
      ny = y + dy[i]

  if nx < 1 or ny <1 or nx > n or ny > n:
    continue
  x, y = nx, ny

print(x, y)


------------------------------------------------------------------------------------------------------------
시각 문제 설명

정수 N이 입력되면 00시 00분 00초부터 N시 59분59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 작성하세요. 

입력조건 : 첫째 줄에 정수 N 이 입력된다 (0 <= N <= 23)
출력조건 : 00시 00분 00초부터 N시 59분 59초까지의 모든 시각중에서 3이 하나라도 포함되는 모든 경우의 수를 출력한다. 

문제해결아이디어

가능한 모든 시각의 경우를 하나씩 모두 세서 풀 수 있는 문제
하루는 86400초이므로 가능한 모든 경우는 86400가지 
따라서 단순히 시각을 1씩 증가시키면서 3이 하나라도 포함되어 있는지를 확인하면된다. 
이러한 유형을 완전탐색(Brute Forcing)문제 유형이라고 불립니다. 
가능한 모든 경우의 수를 모두 검사해보는 탐색 방법을 의미한다. 


h = int(input())

count = 0

for i in range(h + 1):
    for j in range(60):
        for k in range(60):
            if '3' in str(i) + str(j) + str(k):
                count += 1
print(count) 

왕실의 나이트 문제 
행복왕국의 왕실정원은 체스판과 같은 8x8 좌표 평면입니다. 왕실정원의 특정한 한 칸에 나이트가 서있다. 
나이트는 매우 충성스러운 신하로서 매일 무술을 연마한다. 나이트는 말을 타고 있기 때문에 이동을 할 때는
L자 형태로만 이동할 수 있으며 정원 밖으로는 나갈 수 없다. 
나이트는 특정위치에서 다음 2가지 경우로 이동할수 있다. 
1.수평으로 두칸 이동한 뒤에 수직으로 한칸 이동
2. 수직으로 두칸 이동한 뒤에 수평으로 한칸 이동
이 8x8 좌표평면상에서 나이트의 위치가 주어졌을 때 나이트가 이동할 수 있는 경우의 수를 출력하는 프로그램을 작성. 

입력조건 : 첫째 줄에 8x8 좌표 평면상에서 현태 나이트가 위치한 곳의 좌표를 나타내는 두 문자 로 구성된 문자열이 입력된다. 
출력조건 : 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력
###
알고리즘

나이트의 8가지 경로를 하나씩 확인하며 각 위치로 이동이 가능한지 확인 
dx = [2, 2, -2, -2, 1, 1, -1, -1] 
dy = [1, -1, 1, -1, 2, -2, 2, -2]

#현재 나이트의 위치 입력받기
input_data = input()
row = int(input_data[1])
column = int(ord(input_data[0])) - int(ord('a')) + 1

#나이트가 이동할수 있는 9가지 방향 정의 
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

#8가지 방향에 대해 각 위치로 이동이 가능한지 확인

result = 0 
for step in steps:
    next_row = row + step[0]
    next_column = column + step[1]
    if next_row >= 1 and next_row <= 8 and next_column >=1 and next_column <= 8:
        result += 1

print(result)

문자열 재정렬 문제 설명
알파벳 대문자와 숫자(0~9)로만 구성된 문자열이 입력으로 주어진다. 이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에 그 뒤에 모든 숫자를 더한 값을 이어서 출력한다. 
입력조건 : 첫째 줄에 하나의 문자열 S가 주어진다 (1 <= S <= 10000)
출력조건 : 요구하는 정답을 출력 

아이디어 
문자열이 입력되었을 때 문자를 하나씩 확인한다. 
숫자인 경우 따로 합계를 계산한다. 
알파벳의 경우 별도의 리스트에 저장한다 
결과적으로 리스트에 저장된 알파벳을 정렬해 출력하고, 합계를 뒤에 붙여 출력하면 정답. 

data = input()
result = []
value = 0

#문자를 하나씩 확인하며 
for x in data:
    if x.isalpha():
        result.append(x)
    else:
        value += int(x)

result.sort()

if value != 0:
    result.append(str(value))

print(''.join(result))
