그리디 알고리즘 
그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다. 
일반적인 그리디 알고리즘은 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다. 
그리디 해법은 그 정당성 분석이 중요하다 
단순히 가장 좋아보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토한다. 

일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많다 
하지만 코딩테스트에서의 대부분의 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서, 이를 추론 할수 있어야 풀리도록 출제된다. 

거스름돈 문제 

n = 1260
count = 0

array=[500, 100, 50, 10]

for coin in array:
  count += n // coin
  n %= coin 

print(count)


거스름돈 : 시간복잡도 분석 
화폐의 종류가 K라고 할때, 소스코드의 복잡도는 O(K)이다. 
금액과는 무관하며 동전의 총 종류에만 영향을 받는다. 

1이 될 때까지 문제 
문제해결의 아이디어 
주어진 N에 대하여 최대한 만히 나누기를 수행하면 된다. 
N의 값을 줄일 때 2 이상의 수로 나누는 작업이 1을 빼는 작업보다 수를 훨씬 많이 줄일 수 있기 때문 
가능하면 최대한 많이 나누는 작업이 최적의 해를 보장할 수 있는가? (정당성 분석)


답안예시 
#N, K를 공백을 기준으로 구분하여 입력 받기 
n, k = map(int, input().split())

result = 0

while True:
    target = (n // k) * k
    result += (n - target)
    n = target
    #N이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    #K로 나누기 
    result += 1
    n //= k

#마지막으로 남은 수에 대하여 1씩 빼기
result += (n-1)
print(result) 


곱하기 혹은 더하기 문제 
해결 아이디어 
대부분의 경우 + 보다는 * 가 더 값을 크게 만든다 
다만 두 수 중에 하나라도 0 혹은 1인 경우 곱하기 보다는 더하기를 수행하는게 효율적이다 
따라서 두 수에 대하여 연산을 수행할 때, 두 수 중에서 하나라도 1 이하인 경우에는 더하며, 두 수가 모두 2 이상인 경우에는 곱하면 정답이다. 

data = input()

#첫 번째 문자를 숫자로 변경하여 대입 
result = int(data[0])

for i in range(1, len(data)):
    #두 수 중에서 하나라도 0 혹은 1 인 경우, 곱하기 보다는 더하기 수행 
    num = int(data[i])
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num

print(result)

모험가 길드 문제 
문제 설명 
한마을에 모험가가 N명 있다. 
각 모험가는 공포도를 갖는데 공포도가 높을수록 위험에 대처하는 능력이 떨어진다. 
모험가 그룹을 안전하게 구성하고자 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있도록 규정했다. 
최대 몇개의 모험가 그룹을 만들 수 있는지 궁금하다. N명의 모험가에 대한 정보가 주어 졌을 때 여행을 떠날수 있는 그룹수의 최댓값을 구하는 프로그램을 작성하라. 
예를 들어 공포도가 2인 모험가는 2명 이상의 그룹.
	공포도가 3인 모험가는 3명 이상의 그룹
	공포도가 4인 모험가는 4명 이상의 그룹 
또한 몇명의 모험가는 마을에 그대로 남아 있어도 되기 때문에, 모든 모험가를 특정한 그룹에 넣을 필요는 없다. 

입력조건 : 모험가의 수 N이 주어진다. / 각 모험가의 공포도의 값을 N이하의자연수로 주어지며 각 자연수는 공백으로 구분한다. 
출력조건 : 여행을 떠날 수 있는 그룹 수의 최댓값을 출력한다. 

답안예시 

n = int(input())
data = list(map(int, input().split()))

data.sort()

result = 0 # 총 그룹의 수 
count = 0 # 현재 그룹에 포함된 모험가의 수 

for i in data: #공포도를 낮은 것부터 하나씩 확인하며
  count += 1 # 현재 그룹에 해당 모험가를 포함시키기 
  if count >= i: # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면 그룹결성
    result += 1 # 총 그룹의 수 증가시키기
    count = 0 # 현재 그룹에 포함된 모험가의 수 초기화

print(result) #총 그룹의 수 출력 




